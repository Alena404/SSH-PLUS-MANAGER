#!/usr/bin/env python3
import psutil
import pwd
import os
import re
import time
from datetime import datetime, timedelta

# --- Configuration ---
USERS_DB = "/root/users.db"
OPENVPN_STATUS_LOG = "/etc/openvpn/openvpn-status.log"
AUTH_LOG = "/var/log/auth.log" # For dropbear login info

COLOR_RESET = "\033[0m"
COLOR_YELLOW = "\033[1;33m"
COLOR_GREEN = "\033[1;32m"
COLOR_RED = "\033[1;31m"
COLOR_CYAN = "\033[1;36m"
COLOR_BLUE = "\033[0;34m"

def get_users_from_db():
    """Reads users and their limits from /root/users.db."""
    users_data = {}
    if os.path.exists(USERS_DB):
        with open(USERS_DB, 'r') as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) >= 2:
                    username = parts[0]
                    limit = int(parts[1])
                    users_data[username] = {"limit": limit, "connections": 0, "active_sessions": []}
    return users_data

def get_all_system_users():
    """Gets all system users with a UID >= 1000, excluding 'nobody'."""
    system_users = set()
    for p in pwd.getpwall():
        if p.pw_uid >= 1000 and p.pw_name != 'nobody':
            system_users.add(p.pw_name)
    return system_users

def get_ssh_connections(username):
    """Gets active SSH connections for a given user."""
    connections = []
    for conn in psutil.net_connections(kind='inet'):
        if conn.status == psutil.CONN_ESTABLISHED and conn.laddr and conn.raddr:
            try:
                # Check for SSH processes associated with the user
                # This is a bit indirect, but psutil doesn't directly link connections to users
                # We'll rely on iterating processes for user and then checking their open files/ports
                for proc in psutil.process_iter(['pid', 'name', 'username', 'create_time']):
                    if proc.info['username'] == username and 'ssh' in proc.info['name']:
                         # Further refine by checking if the process is associated with this connection
                         # For simplicity, we are just counting open 'sshd' processes for the user
                        if conn.laddr.port == 22 or conn.laddr.port in get_ssh_ports(): # Assuming default SSH port or custom ports
                             connections.append(proc.info)
                             break # Found one relevant process for this connection type
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
    return connections

def get_ssh_ports():
    """Reads SSH ports from sshd_config."""
    ports = {22} # Default SSH port
    if os.path.exists('/etc/ssh/sshd_config'):
        with open('/etc/ssh/sshd_config', 'r') as f:
            for line in f:
                if line.strip().startswith('Port'):
                    try:
                        port = int(line.strip().split()[1])
                        ports.add(port)
                    except ValueError:
                        pass
    return list(ports)

def get_dropbear_connections(username):
    """Gets active Dropbear connections for a given user by parsing auth.log."""
    connections = []
    dropbear_pids = []
    
    # Find active dropbear processes
    for proc in psutil.process_iter(['pid', 'name', 'username', 'cmdline', 'create_time']):
        if 'dropbear' in proc.info['name'] and proc.info['username'] == 'root': # dropbear usually runs as root
            cmdline = proc.info['cmdline']
            if cmdline and any(f'-p{p}' in arg for p in get_dropbear_ports() for arg in cmdline):
                dropbear_pids.append(proc.info['pid'])

    if not dropbear_pids:
        return connections

    # Parse auth.log for successful logins
    if os.path.exists(AUTH_LOG):
        with open(AUTH_LOG, 'r', errors='ignore') as f:
            log_content = f.read()
            for pid in dropbear_pids:
                # Regex to find successful logins for the user associated with this PID
                # This pattern is simplified and might need adjustment based on actual log format
                # Example: "Jan 1 12:00:00 hostname dropbear[PID]: Password auth succeeded for 'user' from IP:PORT"
                pattern = rf"dropbear\\\[{pid}\\]: Password auth succeeded for '{username}'"
                if re.search(pattern, log_content):
                    connections.append({"pid": pid, "user": username, "type": "Dropbear"})
    return connections

def get_dropbear_ports():
    """Reads Dropbear ports from /etc/default/dropbear."""
    ports = set()
    if os.path.exists('/etc/default/dropbear'):
        with open('/etc/default/dropbear', 'r') as f:
            for line in f:
                if line.strip().startswith('DROPBEAR_PORT='):
                    try:
                        port = int(line.strip().split('=')[1])
                        ports.add(port)
                    except ValueError:
                        pass
                if line.strip().startswith('DROPBEAR_EXTRA_ARGS='):
                    match = re.search(r'-p\s+(\d+)', line)
                    if match:
                        try:
                            port = int(match.group(1))
                            ports.add(port)
                        except ValueError:
                            pass
    return list(ports) or [22] # Default to SSH port if no dropbear config

def get_openvpn_connections(username):
    """Gets active OpenVPN connections for a given user."""
    connections = []
    if os.path.exists(OPENVPN_STATUS_LOG):
        with open(OPENVPN_STATUS_LOG, 'r') as f:
            content = f.read()
            # The client list section usually starts with "CLIENT_LIST"
            # Each client entry has the format: COMMON_NAME,REAL_ADDRESS,VIRTUAL_ADDRESS,BYTES_RECEIVED,BYTES_SENT,CONNECTED_SINCE
            client_list_match = re.search(r'CLIENT_LIST(?P<clients>.*?)(?=\nROUTING_TABLE|\nGLOBAL_STATS|\Z)', content, re.DOTALL)
            if client_list_match:
                clients_section = client_list_match.group('clients')
                for line in clients_section.splitlines():
                    if line.startswith(username + ','):
                        parts = line.split(',')
                        if len(parts) >= 6:
                            connected_since_timestamp = datetime.strptime(parts[5], '%a %b %d %H:%M:%S %Y')
                            connections.append({"user": username, "connected_since": connected_since_timestamp, "type": "OpenVPN"})
    return connections

def format_time_diff(start_time_timestamp):
    """Formats the time difference from a given timestamp to now."""
    now = datetime.now()
    diff = now - start_time_timestamp
    
    hours, remainder = divmod(int(diff.total_seconds()), 3600)
    minutes, seconds = divmod(remainder, 60)
    
    return f"{hours:02}:{minutes:02}:{seconds:02}"

def main():
    system("clear")
    users_data = get_users_from_db()
    system_users = get_all_system_users()

    # Ensure all system users with UID >= 1000 are in users_data for display
    for s_user in system_users:
        if s_user not in users_data:
            users_data[s_user] = {"limit": 1, "connections": 0, "active_sessions": []} # Default limit 1 if not in DB

    # Add special handling for root, which might have SSH connections but no entry in users.db
    if 'root' not in users_data:
        users_data['root'] = {"limit": 0, "connections": 0, "active_sessions": []} # No limit for root, usually

    # Get active sessions
    for p in psutil.process_iter(['pid', 'name', 'username', 'create_time', 'connections']):
        try:
            p_username = p.info['username']
            p_name = p.info['name']
            
            # Skip if user is not in our managed list
            if p_username not in users_data and p_username not in system_users:
                continue

            # SSHD connections
            if p_name == 'sshd' and p_username in users_data:
                # Filter for actual user sessions, not parent sshd processes
                if "sshd: " + p_username in " ".join(p.cmdline()): # heuristic to find user specific sshd processes
                    start_time = datetime.fromtimestamp(p.info['create_time'])
                    users_data[p_username]["connections"] += 1
                    users_data[p_username]["active_sessions"].append({
                        "pid": p.info['pid'],
                        "type": "SSHD",
                        "start_time": start_time
                    })
            
            # OpenVPN connections (handled separately via log file, but process can exist)
            # Dropbear connections (handled separately via log file, but process can exist)

        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            continue

    # Incorporate OpenVPN and Dropbear connections
    all_active_openvpn_users = {}
    for conn in get_openvpn_connections_from_system():
        user = conn.get("user")
        if user not in all_active_openvpn_users:
            all_active_openvpn_users[user] = []
        all_active_openvpn_users[user].append(conn)

    for user in users_data:
        # Get OpenVPN connections from status log
        openvpn_conns = get_openvpn_connections(user)
        for conn in openvpn_conns:
            if user in users_data:
                users_data[user]["connections"] += 1
                users_data[user]["active_sessions"].append({
                    "type": "OpenVPN",
                    "start_time": conn["connected_since"]
                })
        
        # Get Dropbear connections (simplified - actual connections are harder to map directly via psutil)
        # For Dropbear, we'll count processes directly
        for p in psutil.process_iter(['pid', 'name', 'username', 'cmdline', 'create_time']):
            try:
                if 'dropbear' in p.info['name'] and p.info['username'] == user:
                     # Heuristic: check if cmdline contains the username
                    if any(user in arg for arg in p.cmdline()):
                        start_time = datetime.fromtimestamp(p.info['create_time'])
                        users_data[user]["connections"] += 1
                        users_data[user]["active_sessions"].append({
                            "pid": p.info['pid'],
                            "type": "Dropbear",
                            "start_time": start_time
                        })
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                continue


    print(f"{COLOR_YELLOW}User".ljust(15), f"Status".ljust(12), f"Connection".ljust(12), f"Time{COLOR_RESET}")
    print(f"{COLOR_BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{COLOR_RESET}")

    for username in sorted(users_data.keys()):
        user_info = users_data[username]
        current_connections = user_info["connections"]
        limit = user_info["limit"]

        status = f"{COLOR_RED}Offline"
        connection_info = f"{current_connections}/{limit}"
        session_time = "00:00:00"

        if current_connections > 0:
            status = f"{COLOR_GREEN}Online"
            # Find the longest active session to display its time
            if user_info["active_sessions"]:
                longest_session_start_time = min(s["start_time"] for s in user_info["active_sessions"])
                session_time = format_time_diff(longest_session_start_time)
        
        # Color connection count if over limit
        if current_connections > limit and limit != 0:
            connection_info = f"{COLOR_RED}{current_connections}{COLOR_RESET}/{limit}"
        else:
            connection_info = f"{COLOR_CYAN}{current_connections}{COLOR_RESET}/{limit}"


        print(f"{COLOR_YELLOW}{username.ljust(15)}{COLOR_RESET}", 
              f"{status.ljust(20)}{COLOR_RESET}", # Adjusted padding for color codes
              f"{connection_info.ljust(20)}{COLOR_RESET}", 
              f"{COLOR_CYAN}{session_time}{COLOR_RESET}")
        print(f"{COLOR_BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{COLOR_RESET}")

    # Display totals
    total_users = len(users_data)
    online_users = sum(1 for user_info in users_data.values() if user_info["connections"] > 0)
    # The bash script had a separate count for expired users, which is not directly part of this monitor
    # It seems to be derived from expcleaner. We'll leave it out for now as this script focuses on active connections.
    
    print(f"{COLOR_YELLOW}• {COLOR_CYAN}TOTAL USERS{COLOR_RESET}: {total_users} {COLOR_YELLOW}• {COLOR_GREEN}ONLINE USERS{COLOR_RESET}: {online_users} {COLOR_YELLOW}•{COLOR_RESET}")

def get_openvpn_connections_from_system():
    """
    Retrieves OpenVPN connections directly from the status log.
    This function is a helper to centralize OpenVPN parsing.
    """
    connections = []
    if os.path.exists(OPENVPN_STATUS_LOG):
        with open(OPENVPN_STATUS_LOG, 'r') as f:
            content = f.read()
            client_list_match = re.search(r'CLIENT_LIST(?P<clients>.*?)(?=\nROUTING_TABLE|\nGLOBAL_STATS|\Z)', content, re.DOTALL)
            if client_list_match:
                clients_section = client_list_match.group('clients')
                for line in clients_section.splitlines():
                    parts = line.split(',')
                    if len(parts) >= 6:
                        username = parts[0]
                        connected_since_timestamp = datetime.strptime(parts[5], '%a %b %d %H:%M:%S %Y')
                        connections.append({"user": username, "connected_since": connected_since_timestamp, "type": "OpenVPN"})
    return connections

if __name__ == '__main__':
    main()